<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" class="svg" lang="fr"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    
    <link rel="alternate" hreflang="en" href="https://ocaml.org/learn/tutorials/functional_programming.html">
<link rel="alternate" hreflang="fr" href="https://ocaml.org/learn/tutorials/functional_programming.fr.html">
<link rel="alternate" hreflang="it" href="https://ocaml.org/learn/tutorials/functional_programming.it.html">
<link rel="alternate" hreflang="ja" href="https://ocaml.org/learn/tutorials/functional_programming.ja.html">
<link rel="alternate" hreflang="zh" href="https://ocaml.org/learn/tutorials/functional_programming.zh.html">

    
    <title>Programmation Fonctionnelle – OCaml</title>
    <link href="https://ocaml.org/img/favicon32x32.ico" rel="shortcut icon" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Google Web Fonts -->
    <link href="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/css_002.css" rel="stylesheet">
    <link href="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/css.css" rel="stylesheet">
    <link href="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/css_003.css" rel="stylesheet" type="text/css">
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/bootstrap.css" rel="stylesheet" media="screen">
    <link href="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/bootstrap_mod.css" rel="stylesheet" media="screen">
    <link href="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/ocamlorg.css" rel="stylesheet" media="screen">
    <script type="text/javascript" defer="defer" async="" src="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/piwik.html"></script><script type="text/javascript" async="" src="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/ga.js"></script><script src="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="https://ocaml.org/index.fr.html"><img src="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/colour-logo-white.svg" class="svg" alt="OCaml"><img src="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/colour-logo-white.png" class="png" alt="OCaml"></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="https://ocaml.org/learn/index.fr.html">Apprendre</a></li>
              <li><a href="https://ocaml.org/docs/index.fr.html">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Contributions</a></li>
              <li><a href="https://ocaml.org/community/index.fr.html">Communauté</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/functional_programming.fr.md" title="Éditer cette page" class="edit-this-page pull-right"><!-- Image in CSS
	      --><span>Éditer cette page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input name="as_sitesearch" value="ocaml.org" type="hidden">
              <input placeholder="Rechercher" class="search-query" name="q" type="text">
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    <!--								-*-html-*- -->
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      <!--								-*-html-*- -->
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="https://ocaml.org/">Home</a><span class="divider"></span></li>
<li><a href="https://ocaml.org/learn/index.fr.html">Apprendre</a><span class="divider"></span></li>
<li><a href="https://ocaml.org/learn/tutorials/index.fr.html">Tutoriel OCaml</a><span class="divider"></span></li>
<li class="active">Programmation Fonctionnelle</li>


    </ol>
    <ul class="translations">
      <li><a href="https://ocaml.org/learn/tutorials/functional_programming.html">en</a></li>
<li class="active">fr</li>
<li><a href="https://ocaml.org/learn/tutorials/functional_programming.it.html">it</a></li>
<li><a href="https://ocaml.org/learn/tutorials/functional_programming.ja.html">日本語</a></li>
<li><a href="https://ocaml.org/learn/tutorials/functional_programming.zh.html">中文</a></li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contenu</a></li>
          <ul><li><a href="#Qu39estcequelaprogrammationfonctionnelle">Qu'est-ce que la programmation fonctionnelle ?</a>
</li><li><a href="#Applicationpartielleetcurryfication">Application partielle et curryfication</a>
</li><li><a href="#Enquoilaprogrammationfonctionnelleestelleutile">En quoi la programmation fonctionnelle est-elle utile ?</a>
</li><li><a href="#Programmationfonctionnellepureetimpure">Programmation fonctionnelle pure et impure</a>
</li><li><a href="#Evaluationstricteparesseusestrictnessvslaziness">Evaluation stricte / paresseuse (strictness vs laziness)</a>
</li><li><a href="#Boxedvsunboxedtypes">Boxed vs. unboxed types</a>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tbody><tr><td id="text-x"><code></code></td> <td></td></tr>
              </tbody></table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        <!--   -->

<h1 id="Programmationfonctionnelle">Programmation fonctionnelle</h1>

<h2 id="Qu39estcequelaprogrammationfonctionnelle">Qu'est-ce que la programmation fonctionnelle ?</h2><p>Nous sommes arrivés relativement loin dans ce tutoriel et nous n'avons
pas encore abordé la <strong>programmation fonctionnelle</strong>. Il serait
imaginable de voir toutes les fonctionnalités données jusqu'à présent -
rich data types, pattern matching, inférence de types, fonctions
imbriquées - dans une espèce de «&nbsp;Super langage C&nbsp;». Ce sont certainement
des fonctionnalités «&nbsp;cools&nbsp;» qui rendent le code concis, facile à lire et
qui permettent d'avoir moins de bugs, mais elles n'ont que très peu à
voir avec la programmation fonctionnelle.</p>
<p>En fait, la raison pour laquelle les langages fonctionnels sont si bien
n'est <em>pas</em> grâce à la programmation fonctionnelle, mais parce que nous
sommes restés avec des langages de type C pendant des années et pendant
ce temps la pointe de la programmation a avancé considérablement.</p>
<p>Ainsi pendant que nous écrivions <code>struct { int type; union { ... } }</code>
pour la n-ième fois, les programmeurs ML et Haskell avaient déjà les
safe variants et le pattern matching sur les types de données. Pendant
qu'on faisait attention à bien faire des <code>free()</code> pour chaque
<code>malloc()</code>, les langages à garbage collectors avaient implémenté une
façon de gérer automatiquement la mémoire depuis les années 80.</p>
<p>Maintenant, arrêtons de tourner autour du pot, et abordons ce qu'est la
programmation fonctionnelle.</p>
<p>La définition de base, bien que pas forcément claire est : «&nbsp;Dans un
langage fonctionnel, les fonctions sont des citoyens de première classe&nbsp;».</p>
<p>Que de mots qui n'ont pas vraiment de sens. Voyons plutôt un exemple :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">double</span> <span class="ocaml-variable">x </span>= x *2 <span class="governing">in</span>
  <span class="ocaml-module">List</span>.map double [ 1; 2; 3 ]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [2; 4; 6]
</span></code></pre>

<p>Dans cet exemple, j'ai d'abord défini une fonction imbriquée appelée
<code>double</code> qui prend un argument <code>x</code> et qui retourne <code>x * 2</code>. Puis <code>map</code>
appelle <code>double</code> sur chaque élément de la liste donnée <code>([1; 2; 3])</code>
pour produire le résultat : une liste avec chaque nombre doublé.</p>
<p><code>map</code> est appelé une <strong>fonction d'ordre supérieur</strong> (<strong>higher-order function</strong>, HOF).
Les HOF sont juste une jolie manière de dire que la fonction prend une 
fonction parmi ses arguments.</p>
<p>Si vous êtes familiers avec le C/C++, alors cela ressemble au passage
d'un pointeur de fonction. Java a une espèce d'abomination qu'on appelle
une classe anonyme qui est une clôture stupide, lente et peu pratique.
Si vous connaissez Perl alors vous devez déjà avoir utilisé les clôtures
de Perl et sa fonction <code>map</code>, qui est exactement ce dont nous parlons.
En fait, perl est un plutôt bon langage fonctionnel.</p>
<p>Les <strong>clôtures</strong> sont des fonctions qui portent une partie de
l'«&nbsp;environnement&nbsp;» dans lequel elles ont été définies. En particulier,
une clôture peut référencer des variables qui sont disponibles au moment
de la définition. Généralisons la fonction précédente de façon à
prendre n'importe quelle liste d'entiers et multiplier chaque élément
par une valeur <code>n</code> arbitraire :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">multiply</span> <span class="ocaml-variable">n list </span>=
    <span class="governing">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">x </span>=
      n * x <span class="governing">in</span>
    <span class="ocaml-module">List</span>.map f list</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>Ainsi :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">multiply 2 [1; 2; 3]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [2; 4; 6]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">multiply 5 [1; 2; 3]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [5; 10; 15]
</span></code></pre>

<p>Le point important à noter à propos de la fonction <code>multiply</code> est la
fonction imbriquée <code>f</code>. C'est une clôture. Regardez comment <code>f</code> utilise
la valeur de <code>n</code> qui n'est pas passé en tant qu'argument explicite à
<code>f</code>. A la place, <code>f</code> est pris de l'environnement - c'est un argument de
la fonction <code>multiply</code>, ainsi disponible au sein de cette fonction.</p>
<p>Ceci peut paraître un peu trop raccourci, mais regardons de plus près
cet appel à <code>map</code> : <code>List.map f list</code></p>
<p><code>map</code> est défini dans le module <code>List</code>, très loin du code courant. En
d'autres mots, nous passons <code>f</code> dans un module défini «&nbsp;Il y a bien
longtemps, dans une galaxie lointaine, très lointaine&nbsp;».
Tout ce que nous pouvons savoir c'est que ce
code peut passer f à d'autres modules ou en garder une référence quelque
part et l'appeler ultérieurement. Que ce soit le cas ou non, cette
clôture va assurer que <code>f</code> ait toujours accès à l'environnement hérité,
donc à <code>n</code>.</p>
<p>Voici un exemple concret de lablgtk. Ceci est une méthode d'une classe
(nous n'avons pas encore abordé les classes et les objets pour
l'instant, mais considérons juste cela comme une définition de fonction
pour l'instant).</p>
<pre><code class="ocaml"><span class="governing">class</span> <span class="ocaml-function">html_skel</span> <span class="ocaml-variable">obj </span>= <span class="governing">object</span> (self)
  ...
  ...
  <span class="governing">method</span> <span class="ocaml-function">save_to_channel</span> <span class="ocaml-variable">chan </span>=
    <span class="governing">let</span> <span class="ocaml-function">receiver_fn</span> <span class="ocaml-variable">content </span>=
      output_string chan content;
      true <span class="governing">in</span>
    save obj receiver_fn
<span class="governing">end</span></code></pre>

<p>Tout d'abord, il faut savoir que la fonction <code>save</code> appelée à la fin de
la méthode prend en second argument une fonction, en l'occurence
<code>receiver_fn</code>. Elle l'appelle à répétition avec des morceaux de textes que
du widget qu'elle essaye d'enregistrer.</p>
<p>Maintenant, jettons un oeil à <code>receiver_fn</code>. Cette fonction est une
clôture correcte parce qu'elle garde une référence à <code>chan</code> venant de
son environnement.</p>
<h2 id="Applicationpartielleetcurryfication">Application partielle et curryfication</h2><p>Définissons une fonction plus qui ne fait qu'ajouter deux entiers :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">plus</span> <span class="ocaml-variable">a b </span>= a + b</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val plus : int -&gt; int -&gt; int = &lt;fun&gt;
</span></code></pre>

<p>Quelques questions pour les endormis du fond de la classe :</p>
<ol><li>Qu'est-ce que <code>plus</code> ?</li><li>Qu'est-ce que <code>plus 2 3</code> ?</li><li>Qu'est-ce que <code>plus 2</code> ?</li></ol>

<p>La première réponse est facile. <code>plus</code> est une fonction qui prend deux
arguments qui sont entiers et qui retourne un entier. Son type s'écrit
ainsi :</p>
<pre><code class="ocaml">plus : int -&gt; int -&gt; int</code></pre>

<p>La deuxième réponse est encore plus évidente. <code>plus 2 3</code> est un nombre,
l'entier <code>5</code>. Sa valeur et son type s'écrivent :</p>
<pre><code class="ocaml">5 : int</code></pre>

<p>Mais quid de la question 3 ? Il semblerait que <code>plus 2</code> soit une erreur,
un bug. Alors qu'en fait, il n'en est point. Si nous typons cela dans le
toplevel d'OCaml, nous obtenons :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">plus 2</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int -&gt; int = &lt;fun&gt;
</span></code></pre>

<p>Ceci n'est pas une erreur. Il nous dit que <code>plus 2</code> est en fait une
<em>fonction</em>, qui prend un <code>int</code> et qui retourne un <code>int</code>. Quelle genre de
fonction cela est-il ? Essayons d'abord de lui donner un nom, puis de
lui donner quelques entiers en argument, pour voir ce que ça donne :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">f</span> = plus 2</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val f : int -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">f 10</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 12
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">f 15</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 17
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">f 99</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 101
</span></code></pre>

<p>Ceci est une <a href="https://ocaml.org/learn/tutorials/humor_proof.html">preuve par l'exemple</a>
suffisante pour nous dire que <code>plus 2</code> est la fonction qui ajoute 2 à des
choses.</p>
<p>Revenons à la définition originelle et remplaçons le premier argument,
soit <code>a</code>, par la valeur <code>2</code> pour obtenir :</p>
<pre><code class="ocaml"><span class="governing">let </span>plus 2 b = 2 + b <span class="ocaml-prompt">;;</span><br><span class="comment">(* /!\ Ce n'est pas du code OCaml valide *)</span></code></pre>

<p>On peut maintenant mieux voir pourquoi <code>plus 2</code> est la fonction qui
ajoute <code>2</code> à quelque chose.</p>
<p>En regardant le type de ces expressions, on peut démystifier la notation
flèchée bizarre utilisée pour les types de fonctions :</p>
<pre><code class="ocaml">     plus : int -&gt; int -&gt; int
   plus 2 : int -&gt; int
 plus 2 3 : int</code></pre>

<p>Ce processus est appelé
<strong><a href="http://fr.wikipedia.org/wiki/Curryfication" title="http://fr.wikipedia.org/wiki/Curryfication">curryfication</a></strong>.
Le nom vient de Haskell Curry qui a été à l'origine de choses
importantes sur le lambda calcul. Comme j'essaye d'éviter d'entrer dans
les mathématiques derrière OCaml, parce que ça rendrait le tutorial très
ennuyeux et inutile, je n'irai pas plus loin sur le sujet. Pour trouver
plus d'informations sur le sujet, une simple <a href="http://www.google.com/search?q=currying" title="http://www.google.com/search?q=currying">recherche
google</a>
suffit.</p>
<p>Vous rappelez-vous des fonctions <code>double</code> et <code>multiply</code> vues
précédemment ? <code>multiply</code> était défini ainsi :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">multiply</span> <span class="ocaml-variable">n list </span>=
    <span class="governing">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">x </span>= n * x <span class="governing">in</span>
    <span class="ocaml-module">List</span>.map f list</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>Nous pouvons maintenant définir <code>double</code>, <code>triple</code>, etc, très facilement
comme suit :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">double</span> = multiply 2</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val double : int list -&gt; int list = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">triple</span> = multiply 3</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val triple : int list -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>Ce sont de réelles fonctions, la preuve :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">double [1; 2; 3]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [2; 4; 6]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">triple [1; 2; 3]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [3; 6; 9]
</span></code></pre>

<p>On peut aussi utiliser l'application partielle (sans la fonction
intermédiaire <code>f</code>) de cette façon :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">multiply</span> <span class="ocaml-variable">n </span>= <span class="ocaml-module">List</span>.map (( * ) n)</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val multiply : int -&gt; int list -&gt; int list = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">double</span> = multiply 2</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val double : int list -&gt; int list = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">triple</span> = multiply 3</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val triple : int list -&gt; int list = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">double [1; 2; 3]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [2; 4; 6]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">triple [1; 2; 3]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [3; 6; 9]
</span></code></pre>

<p>Dans l'exemple ci-dessus,
<code>((*) n) est l'application partielle de la fonction (*)</code>, c'est-à-dire,
multiplier. À noter les espaces ajoutés pour qu'OCaml ne croit pas que
c'est un début de commentaire.</p>
<p>On peut mettre des opérateurs infixes entre parenthèses pour faire des
fonction. Voici une définition identique à la précédente avec la
fonction <code>plus</code> :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">plus</span> = (+)</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val plus : int -&gt; int -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">plus 2 3</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 5
</span></code></pre>

<p>Voici encore plus de curryfication :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.map (plus 2) [1; 2; 3]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [3; 4; 5]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">list_of_functions</span> = <span class="ocaml-module">List</span>.map plus [1; 2; 3]</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val list_of_functions : (int -&gt; int) list = [&lt;fun&gt;; &lt;fun&gt;; &lt;fun&gt;]
</span></code></pre>

<h2 id="Enquoilaprogrammationfonctionnelleestelleutile">En quoi la programmation fonctionnelle est-elle utile ?</h2><p>La programmation fonctionnelle, comme n'importe quelle technique de
programmation, est un outil utile dans votre boite à outils pour
résoudre certaines classes de problèmes. Très utile pour les callbacks,
qui sont utilisés dans les IHMs pour les boucles d'évènements. C'est
excellent pour exprimer des algorithmes génériques. <code>List.map</code> est une
fonction générique pour appliquer des fonctions sur n'importe quel type
de liste. De la même manière, on peut définir des fonctions génériques
sur les arbres. Certains types de problèmes d'arithmétiques peuvent être
résolus plus rapidement avec la programmation fonctionnelle (par exemple
calculer la dérivé d'une fonction mathématique).</p>
<h2 id="Programmationfonctionnellepureetimpure">Programmation fonctionnelle pure et impure</h2><p>Une <strong>fonction pure</strong> est une fonction sans aucun <strong>effet de bord</strong>. Un
effet de bord signifie que la fonction garde une sorte d'état caché en
son sein. <code>strlen()</code> est un exemple de fonction pure en C. Si on appelle
<code>strlen()</code> avec la même chaîne, elle retournera toujours la même taille.
La sortie de <code>strlen()</code> (la taille) ne dépend que des entrées (la
chaîne) et de rien d'autre. Plein de fonctions en C sont, malheureusement,
impures. Par exemple, <code>malloc()</code>, évidemment, repose sur beaucoup
d'éléments d'états internes (les objets alloués sur le tas, le type
d'allocation utilisé, la façon de prendre des pages de l'OS, etc..).</p>
<p>Les langages dérivés de ML tel que OCaml sont «&nbsp;presque purs&nbsp;». Ils
autorisent des effets de bord au travers des références et des tableaux,
mais la plupart des codes que vous écrirez seront fonctionnels purs
parce qu'ils encouragent cette pensée. Haskell, un autre langage
fonctionnel, est pur fonctionnel. OCaml est donc plus pratique parce
qu'écrire des fonctions impures est parfois utile.</p>
<p>Voici les avantages théoriques d'avoir des fonctions pures. Un avantage
est que si une fonction est pure, alors elle peut être appelée plusieurs
fois avec les même arguments, le compilateur n'aura qu'a appeler la
fonction qu'une seule fois. Un bon exemple en C est :</p>
<pre class="C"><code class="C">for (i = 0; i &lt; strlen(s); ++i) {
    // Du code qui n'affecte pas s
}</code></pre><p>Si nativement compilé, la boucle est en O(n²) sur la taille de s parce
que <code>strlen(s)</code> est appelé à chaque fois et <code>strlen()</code> doit itérer sur
tout <code>s</code>. Si le compilateur est assez intelligent pour se rendre compte
que <code>strlen()</code> est purement fonctionnel <em>et</em> que <code>s</code> n'est pas modifié
dans la boucle, alors il peut retirer les appels redondants à <code>strlen()</code>
et passer la boucle en O(n). Les compilateurs font-ils vraiment cela ?
Dans le cas de <code>strlen</code> très certainement, mais dans d'autres,
probablement pas.</p>
<p>Se concentrer en écrivant des fonctions fonctionnelles pures permettent
d'écrire du code réutilisable en utilisant l'approche bottom-up, testant
chaque petite fonction au fur et à mesure de l'avancement. La mode
actuelle est de projeter les programmes en utilisant une approche
top-bottom, mais dans l'opinion de l'auteur, cela résulte souvent à des
échecs de projets.</p>
<h2 id="Evaluationstricteparesseusestrictnessvslaziness">Evaluation stricte / paresseuse (strictness vs laziness)</h2><p>Les langages dérivés de C et de ML sont stricts. Haskell et Miranda ne
sont pas stricts, c'est-à-dire que ce sont des langages à évaluation
paresseuse. OCaml est strict par défaut mais autorise l'évaluation
paresseuse lorsque nécessaire.</p>
<p>Dans un langage à évaluation stricte, les arguments des fonctions sont
toujours évalués en premier, puis le résultat est alors passé à la
fonction. Par exemple dans un langage à évaluation stricte, cet appel va
toujours sortir par une erreur de division par zéro :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">give_me_a_three</span> <span class="ocaml-variable">x </span>= 3</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val give_me_a_three : 'a -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">give_me_a_three (1/0)</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>Exception: Division_by_zero.
</span></code></pre>

<p>Si vous avez programmé dans n'importe quel langage conventionnel, c'est
le comportement auquel vous vous attendrez et vous serez surpris qu'il
en soit autrement.</p>
<p>Dans un langage à évaluation paresseuse, des choses bizarres se passent.
Les arguments de fonction ne sont évalués que si la fonction les
utilise. Vous rappelez-vous que la fonction <code>give_me_a_three</code> n'utilise
pas ses arguments et retourne toujours 3&nbsp;? Dans un langage à évaluation
paresseuse, cet appel précédent ne fera <em>pas</em> d'erreur, simplement parce
que <code>give_me_a_three</code> ne regarde jamais ses arguments, donc si
l'argument n'est jamais évalué, la division par zéro n'arrive pas.</p>
<p>Les langages à analyse paresseuse permettent de faire d'autres choses
bizarres, comme la définition d'une liste infinie. Tant qu'on n'essaye pas
d'itérer sur la totalité de la liste, cela fonctionne.</p>
<p>OCaml est un langage à évaluation stricte, mais a un module d'évaluation
paresseuse (<code>Lazy</code>) qui permettent d'écrire des expressions paresseuses.
Voici un exemple. D'abord, nous créons une expression paresseuse pour
<code>1/0</code> :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">lazy_expr</span> = lazy (1/0)</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val lazy_expr : int lazy_t = &lt;lazy&gt;
</span></code></pre>

<p>A noter que le type de l'expression est <code>int lazy_t</code></p>
<p>Parce que <code>give_me_a_three</code> prend un <code>'a</code> (tout type) nous pouvons passer
cette expression à la fonction :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">give_me_a_three lazy_expr</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 3
</span></code></pre>

<p>Pour évaluer une expression paresseuse, nous devons utiliser la fonction
<code>Lazy.force</code> :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">Lazy</span>.force lazy_expr</span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>Exception: Division_by_zero.
</span></code></pre>

<h2 id="Boxedvsunboxedtypes">Boxed vs. unboxed types</h2><p>(NDT: trouver une traduction correcte pour «&nbsp;boxed&nbsp;» et «&nbsp;unboxed&nbsp;»)</p>
<p>Un terme qu'on entend beaucoup lorsqu'on parle de langages fonctionnels
est «&nbsp;boxed&nbsp;». J'étais très confus lorsque j'ai entendu ce terme pour la
première fois, mais en fait la distinction entre types «&nbsp;boxed&nbsp;» et
«&nbsp;unboxed&nbsp;» est très simple si vous avez déjà fait du C, du C++ ou du java
avant (en Perl tout est «&nbsp;boxed&nbsp;»).</p>
<p>La façon de voir un objet «&nbsp;boxed&nbsp;» est de penser à un objet qui a été
alloué dans le tas en utilisant <code>malloc()</code> en C (ou <code>new</code> en C++), et/ou
qui est référé via un pointeur. Prenons ce programme C :</p>
<pre class="C"><code class="C">#include &lt;stdio.h&gt;

void printit (int* ptr) {
    printf("the number is %d\n", *ptr);
}

int main () {
    int a = 3;
    int *p = &amp;a;

    printit (p);

    return 0;
}</code></pre><p>La variable <code>a</code> est allouée dans la pile, et est clairement «&nbsp;unboxed&nbsp;».</p>
<p>La fonction <code>printit()</code> prends un entier «&nbsp;boxed&nbsp;» et l'affiche.</p>
<p>Le diagramme ci-dessous (NDT: non-existant à l'écriture de la
traduction) montre un tableau de «&nbsp;unboxed&nbsp;» (en haut) face à des entiers
«&nbsp;unboxed&nbsp;» (en bas) :</p>
<p><img src="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/boxedarray.png" alt="Boxed Array"></p>
<p>Il n'est pas difficile de deviner que le tableau d'entiers «&nbsp;unboxed&nbsp;» est
plus rapide que le tableau d'entiers «&nbsp;boxed&nbsp;». De plus, parce qu'il y a
moins d'allocations séparées, la récupération de la mémoire est plus
rapide et plus simple sur le tableau d'objets «&nbsp;unboxed&nbsp;».</p>
<p>En C ou C++ vous n'aurez aucun problème pour construire chacun des
tableaux ci-dessus. En java, on a deux types, <code>int</code> qui est «&nbsp;unboxed&nbsp;» et
<code>Integer</code> qui est «&nbsp;boxed&nbsp;», donc considérablement moins efficace. En
OCaml, tous les types primitifs sont «&nbsp;unboxed&nbsp;».</p>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	<!-- footer							-*-html-*- -->
<div class="column">
  <div class="entry">
    <h1><a href="https://ocaml.org/learn/index.fr.html">Apprendre</a></h1>
    <ul>
      <li><a href="https://ocaml.org/learn/taste.fr.html">Exemples de code</a></li>
      <li><a href="https://ocaml.org/learn/tutorials/index.fr.html">Tutoriels</a></li>
      <li><a href="https://ocaml.org/learn/books.html">Livres</a></li>
      <li><a href="https://ocaml.org/learn/success.fr.html">Cas d'usage</a></li>
      <li><a href="https://ocaml.org/learn/tutorials/"></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="https://ocaml.org/docs/index.fr.html">Documentation</a></h1>
    <ul>
      <li><a href="https://ocaml.org/docs/install.fr.html">Installer OCaml</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manuel</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Contributions</a></li>
      <li><a href="https://ocaml.org/releases/index.fr.html">Compiler Releases</a></li>
      <li><a href="https://ocaml.org/docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="https://ocaml.org/community/index.fr.html">Communauté</a></h1>
    <ul>
      <li><a href="https://ocaml.org/community/mailing_lists.fr.html">Lieux de discussion</a></li>
      <li><a href="https://ocaml.org/meetings/index.fr.html">Rencontres</a></li>
      <li><a href="https://ocaml.org/community/planet/">Nouvelles</a></li>
      <li><a href="https://ocaml.org/community/support.fr.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Signaler un bug d'OCaml</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Contact</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="https://ocaml.org/about.html">À propos de ce site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Dépôt GitHub</a></li>
      <li><a href="https://ocaml.org/contributors.fr.html">Crédits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    <!-- Load javascript from CDN -->
    <script type="text/javascript" src="Programmation%20Fonctionnelle%20%E2%80%93%20OCaml_fichiers/bootstrap.js"></script>

    
    <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37808023-1']);
    _gaq.push(['_setDomainName', 'ocaml.org']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

    </script>
    <!-- Piwik -->
    <script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(['setCookieDomain', '*.ocaml.org']);
      _paq.push(['setDocumentTitle', 'Programmation Fonctionnelle']);
      _paq.push(['setDoNotTrack', true]);
      _paq.push(['setCustomVariable', 1, 'Page language',
         'French',
         'page']);
      _paq.push(['trackPageView']);
      _paq.push(['enableLinkTracking']);

      (function() {
        var u=(('https:' == document.location.protocol) ? 'https' : 'http') + '://ocaml.org/piwik/';
        _paq.push(['setTrackerUrl', u+'piwik.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0]; g.type='text/javascript';
        g.defer=true; g.async=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
      })();
    </script>
    <noscript><p><img src="//ocaml.org/piwik/piwik.php?idsite=1"
		      style="border:0;" alt="" /></p></noscript>
    <!-- End Piwik Code --> <!-- ifndef staging -->

  

</body></html>