<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" class="svg" lang="fr"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    
    <link rel="alternate" hreflang="en" href="https://ocaml.org/learn/tutorials/modules.html">
<link rel="alternate" hreflang="fr" href="https://ocaml.org/learn/tutorials/modules.fr.html">
<link rel="alternate" hreflang="ja" href="https://ocaml.org/learn/tutorials/modules.ja.html">
<link rel="alternate" hreflang="ko" href="https://ocaml.org/learn/tutorials/modules.ko.html">
<link rel="alternate" hreflang="zh" href="https://ocaml.org/learn/tutorials/modules.zh.html">

    
    <title>Modules – OCaml</title>
    <link href="https://ocaml.org/img/favicon32x32.ico" rel="shortcut icon" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Google Web Fonts -->
    <link href="Modules%20%E2%80%93%20OCaml_fichiers/css_002.css" rel="stylesheet">
    <link href="Modules%20%E2%80%93%20OCaml_fichiers/css.css" rel="stylesheet">
    <link href="Modules%20%E2%80%93%20OCaml_fichiers/css_003.css" rel="stylesheet" type="text/css">
    <!-- Only part of Bootstrap that we don't load from a CDN is our own customized CSS build. -->
    <link href="Modules%20%E2%80%93%20OCaml_fichiers/bootstrap.css" rel="stylesheet" media="screen">
    <link href="Modules%20%E2%80%93%20OCaml_fichiers/bootstrap_mod.css" rel="stylesheet" media="screen">
    <link href="Modules%20%E2%80%93%20OCaml_fichiers/ocamlorg.css" rel="stylesheet" media="screen">
    <script type="text/javascript" defer="defer" async="" src="Modules%20%E2%80%93%20OCaml_fichiers/piwik.html"></script><script type="text/javascript" async="" src="Modules%20%E2%80%93%20OCaml_fichiers/ga.js"></script><script src="Modules%20%E2%80%93%20OCaml_fichiers/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="https://ocaml.org/index.fr.html"><img src="Modules%20%E2%80%93%20OCaml_fichiers/colour-logo-white.svg" class="svg" alt="OCaml"><img src="Modules%20%E2%80%93%20OCaml_fichiers/colour-logo-white.png" class="png" alt="OCaml"></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="https://ocaml.org/learn/index.fr.html">Apprendre</a></li>
              <li><a href="https://ocaml.org/docs/index.fr.html">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Contributions</a></li>
              <li><a href="https://ocaml.org/community/index.fr.html">Communauté</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/modules.fr.md" title="Éditer cette page" class="edit-this-page pull-right"><!-- Image in CSS
	      --><span>Éditer cette page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input name="as_sitesearch" value="ocaml.org" type="hidden">
              <input placeholder="Rechercher" class="search-query" name="q" type="text">
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    <!--								-*-html-*- -->
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      <!--								-*-html-*- -->
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="https://ocaml.org/">Home</a><span class="divider"></span></li>
<li><a href="https://ocaml.org/learn/index.fr.html">Apprendre</a><span class="divider"></span></li>
<li><a href="https://ocaml.org/learn/tutorials/index.fr.html">Tutoriel OCaml</a><span class="divider"></span></li>
<li class="active">Modules</li>


    </ol>
    <ul class="translations">
      <li><a href="https://ocaml.org/learn/tutorials/modules.html">en</a></li>
<li class="active">fr</li>
<li><a href="https://ocaml.org/learn/tutorials/modules.ja.html">日本語</a></li>
<li><a href="https://ocaml.org/learn/tutorials/modules.ko.html">한국어</a></li>
<li><a href="https://ocaml.org/learn/tutorials/modules.zh.html">中文</a></li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contenu</a></li>
          <ul><li><a href="#Usagestandard">Usage standard</a>
</li><li><a href="#Interfacesmodulairesetsignatures">Interfaces modulaires et signatures.</a>
</li><li><a href="#Typesabstraitsvirtuels">Types abstraits (virtuels)</a>
</li><li><a href="#Sousmodules">Sous modules</a>
<ul><li><a href="#Crationd39unsousmodule">Création d'un sous module</a>
</li></ul>
</li><li><a href="#Foncteurs">Foncteurs</a>
<ul><li><a href="#Commentutiliserunfoncteur">Comment utiliser un foncteur ?</a>
</li><li><a href="#Commentdfinirunfoncteur">Comment définir un foncteur ?</a>
</li></ul>
</li><li><a href="#Manipulationpratiquedesmodules">Manipulation pratique des modules</a>
<ul><li><a href="#Afficherl39interfaced39unmodule">Afficher l'interface d'un module</a>
</li><li><a href="#Insertiondansunmodule">Insertion dans un module</a>
</li></ul>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tbody><tr><td id="text-x"><code></code></td> <td></td></tr>
              </tbody></table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        <!--   -->

<h1 id="Modules">Modules</h1>

<h2 id="Usagestandard">Usage standard</h2>

<p>Avec OCaml, tout programme est contenu dans un module. Un module peut
même être, plus rarement, un sous-module d'un autre, à la manière d'une
arborescence de dossiers imbriqués les uns dans les autres.</p>
<p>Lorsqu'on écrit un programme, avec par exemple deux fichiers
<code>amodule.ml</code> et <code>bmodule.ml</code>, ceux ci définissent deux
modules, intitulés respectivement <code>Amodule</code> et <code>Bmodule</code>,
possédant le même contenu que nos fichiers.</p>
<p>Prenons par exemple le fichier amodule.ml suivant:</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">"Hello"</span></code></pre>

<p>ainsi que le fichier bmodule.ml :</p>
<pre><code class="ocaml"><span class="ocaml-module">Amodule</span>.hello ()</code></pre>

<p>En général, les fichiers sont compilés un par un, comme ceci:</p>
<pre class="shell"><code class="shell">ocamlopt -c amodule.ml
ocamlopt -c bmodule.ml
ocamlopt -o hello amodule.cmx bmodule.cmx</code></pre>

<p>Nous avons à présent un petit éxécutable pouvant afficher
«&nbsp;Hello&nbsp;».  Comme on l'a constaté, on accède à n'importe quoi dans un
module donné en appellant le nom du module (qui commence toujours par
une majuscule) suivit d'un point et du nom de l'objet utilisé. Cet
object peut être une variable, un type ou tout autre chose définie au
sein du module.</p>
<p>Les librairies (bibliothèques), notament la bibliothèque standard,
fournit un certain nombre de modules. Par exemple, <code>List.iter</code>
désigne la fonction <code>iter</code> définie au sein du module <code>List</code>.
Si jamais on souhaite utiliser de façon intensive un module, on peut
désirer se passer de l'appel de son nom; il suffit pour cela d'utiliser
l'instrution <code>open</code>.  En poursuivant notre exemple,
<code>bmodule.ml</code> pourrait contenir :</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Amodule</span><span class="ocaml-prompt">;;</span><br>hello ()</code></pre>

<p>Notons que beaucoup de programmeurs «&nbsp;oublient&nbsp;» les <code>;;</code>, il est plus
courant d'écrire</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Amodule</span>
<span class="governing">let </span><span class="ocaml-variable">_</span> = hello ()</code></pre>

<p>L'usage de l'instruction <code>open</code> n'est qu'une question de goût.
Certains modules proposent des noms déjà utilisés dans d'autres modules.
Ainsi le module <code>List</code> contient des fonctions aux noms assez
courants dans les autres modules, aussi on n'écrit assez rarement
<code>open List</code>. D'autres comme <code>Printf</code> utilise des noms très
spécifiques, suffisament rares pour ne pas créer de conflits avec
d'autres modules; pour éviter d'écrire <code>Printf.printf</code> on préfera
utiliser <code>open Printf</code> en début de fichier&nbsp;:</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Printf</span>
<span class="governing">let </span><span class="ocaml-variable">my_data</span> = [ <span class="string">"a"</span>; <span class="string">"beautiful"</span>; <span class="string">"day"</span> ]
<span class="governing">let </span><span class="ocaml-variable">_</span> = <span class="ocaml-module">List</span>.iter (<span class="keyword">fun</span> s -&gt; printf <span class="string">"%s\n"</span> s) my_data</code></pre>

<h2 id="Interfacesmodulairesetsignatures">Interfaces modulaires et signatures.</h2>

<p>Un module peut fournir un grand nombre d'éléments (fonctions, types,
sous modules, variables...) au programme qui l'utilise. Par défaut, tous
les objets définis au sein du module seront accessibles depuis
«&nbsp;l'exterieur&nbsp;». Ceci peut être utile dans de petits programmes, mais il
est préférable qu'un module ne propose que ce qu'il est conçu pour
proposer, sans le fouillis des fonctions auxilliaires ou variables
temporaires. Pour cela, nous pouvons définir une interface modulaire,
qui se comporte comme un filtre entourant le module. De la même façon
qu'un module vient d'un fichier <code>.ml</code>, l'interface corespondante
(et sa signature) viennent d'un fichier <code>.mli</code>. Il contient la
liste des valeurs avec leur type (ou signature pour les fonctions).
Réécrivons notre <code>amodule.ml</code>&nbsp;:</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">"Hello"</span>
<span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message</code></pre>

<p>Tel quel, l'interface de <code>Amodule</code> est la suivante:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">message</span> : string
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit</code></pre>

<p>Supposons que nous souhaitions que personne de l'exterieur ne puisse
accéder à la variable <code>message</code>. Nous choisissons alors de la
cacher en crééant une interface restreinte, le <code>amodule.mli</code> est
alors:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="comment">(** Displays a greeting message. *)</span></code></pre>

<p>(Notons que commenter les fichiers <code>.mli</code> en utilisant le format
d'<code>ocamldoc</code> est une très bonne habitude à prendre).</p>
<p>Les fichiers <code>.mli</code> doivent être compilés juste avant les
<code>.ml</code> correspondants. On peut les compiler à l'aide
d'<code>ocamlc</code>, même si les <code>.ml </code>sont écrit en code natif avec
<code>ocamlopt</code></p>
<pre class="shell"><code class="shell">ocamlc -c amodule.mli
ocamlopt -c amodule.ml
...</code></pre>

<h2 id="Typesabstraitsvirtuels">Types abstraits (virtuels)</h2>

<p>Passons à présent aux définitions de types. Nous avons vu que les
valeurs telles que les fonctions, peuvent être exportées en donnant leur
noms et signatures dans un fichiers <code>.mli</code>, par exemple:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit</code></pre>

<p>Cependant on définit souvent au sein d'un module de nouveaux types.
Prenons par exemple un enregistrement d'une date:</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span> = { day : int;  month : int;  year : int }</code></pre>

<p>Il n'y a plus 2 mais 4 options possibles dans l'écriture du fichier
<code>.mli</code>&nbsp;:</p>
<ol><li>Le type n'est pas précisé dans le <code>.mli</code></li><li>La définition du type est copiée-collée dans le <code>.mli</code></li><li>Le type est rendu virtuel, seul son nom est précisé. (il est connu
 du compilateur mais on ne peut y toucher)</li><li>Les champs d'un enregistrement sont rendus seulement lisibles
 et non plus modifiables (lecture seule) <code>type date = private { ... }</code>.</li></ol>

<p>Dans le troisieme cas, on obtient le code suivant&nbsp;:</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span></code></pre>

<p>Les utilisateurs de ce module peuvent désormais manipuler des données de
type <code>date</code> mais ne peuvent accéder aux champs de
l'enregistrement, seules les fonctions du modules sont autorisées à le
faire. Supposons que notre module contienne trois fonctions, une pour
créer une date, une pour calculer la différence entre deux dates et une
pour convertir une date en années:</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span>
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">create</span> : ?days:int -&gt; ?months:int -&gt; ?years:int -&gt; unit -&gt; date
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">sub</span> : date -&gt; date -&gt; date
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">years</span> : date -&gt; float</code></pre>

<p>On remarque alors que seule <code>create</code> et <code>sub</code> peuvent être
utilisées pour céer des enregistrements de dates. Ainsi il n'est pas
possible pour l'utilisateur de créer des enregistrements difformes.
Ainsi, bien que notre implémentation utilise un enregistrement nous
pouvons le modifier sans qu'aucun fichier utilisant ce module n'en soit
perturbé. Ceci est particulièrement utile dans le cas des librairies,
qui peuvent ainsi être modifiées tout en gardant une utilisation
identique.</p>
<h2 id="Sousmodules">Sous modules</h2>

<h3 id="Crationd39unsousmodule">Création d'un sous module</h3>

<p>Nous avons vu qu'un fichier unique <code>exemple.ml</code> se compilait un un
module unique <code>Exemple</code>. Sa signature est automatiquement générée
et est la plus exhaustive possible, sauf si elle est restreinte par
l'écriture d'un fichier <code>.mli</code> . Ceci dit, un module donné peut
etre définit explicitement au sein même d'un fichier, il est ainsi un
sous module du module principal. Prenons l'exemple suivant:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>= 
<span class="governing">struct</span>
  <span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">"Hello"</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message
<span class="governing">end</span>
  
<span class="governing">let</span> <span class="ocaml-function">goodbye</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">"Goodbye"</span>
<span class="governing">let</span> <span class="ocaml-function">hello_goodbye</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-module">Hello</span>.hello ();
  goodbye ()</code></pre>

<p>Depuis un autre fichier, nous avons désormais deux niveaux de modules.
Nous pouvons écrire alors:</p>
<pre><code class="ocaml"><span class="governing">let</span> () =
  <span class="ocaml-module">Example</span>.<span class="ocaml-module">Hello</span>.hello ();
  <span class="ocaml-module">Example</span>.goodbye ()</code></pre>

<h4 id="Interfacesubmodulaire">Interface submodulaire</h4>

<p>Nous pouvons de même restreindre l'interface d'un sous module. On
appelle cela un type modulaire. Dans notre <code>exemple.ml</code> cela
donne:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>: 
<span class="governing">sig</span>
 <span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="governing">end</span> = 
<span class="governing">struct</span>
  <span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">"Hello"</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message
<span class="governing">end</span>
  
<span class="comment">(* At this point, <span class="ocaml-module">Hello</span>.message is not accessible anymore. *)</span>
<span class="governing">let</span> <span class="ocaml-function">goodbye</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">"Goodbye"</span>
<span class="governing">let</span> <span class="ocaml-function">hello_goodbye</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-module">Hello</span>.hello ();
  goodbye ()</code></pre>

<p>La définition du module <code>Hello</code> est équivalente au couple de
fichiers <code>hello.mli/hello.ml</code> . Cependant, écrire tout cela dans
un même bloc de code n'est pas très élégant, nous préférons donc définir
la signature séparement.</p>
<pre><code class="ocaml"><span class="governing">module <span class="governing">type</span></span> <span class="ocaml-module">Hello_type</span> <span class="ocaml-variable"></span>=
<span class="governing">sig</span>
  <span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="governing">end</span>
  
<span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>: <span class="ocaml-module">Hello_type</span> =
<span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p><code>Hello_type</code> est un type modulaire et peut donc être réutilisée
pour définir d'autres interfaces de modules.</p>
<p>Bien que l'utilisation des sous modules peut se révéler pratique dans
certains cas spécifiques, leur utilité réelle se révèle avec les
foncteurs, développés dans la section suivante.</p>
<h2 id="Foncteurs">Foncteurs</h2>

<p>Les foncteurs sont probablement une des fonctionnalités les plus
complexes d'OCaml, même s'il n'est pas nécessaire de les utiliser de
façon intensive pour être un bon programmeur. En réalité, il est
possible que nous n'ayons jamais à définir nous même de foncteurs, mais
nous serons surement appelés à les rencontrer dans la librairie
standard. Ils sont la seule façcon d'utiliser les modules <code>Set</code> et
<code>Map</code>, mais leur utilisation reste à notre portée.</p>
<p>Un foncteur est un module qui est paramétré par un autre module, tout
comme une fonction n'est qu'une valeur paramétrée par d'autre valeurs
(les arguments). En gros, cela permet de paramétrer un type par une
valeur, ce qui est impossible à faire directment en OCaml. Par exemple,
nous pourrions définir un foncteur prenant un entier <code>n</code> et
retournant un ensemble d'opérations sur des tableaux de longeurs
<code>n</code> uniquement. Si par erreur, un programmeur donne un tableau
normal à une de ces fonctions, le compilateur soulevera une erreur. Si
nous n'utilisions pas un foncteur mais le type standard des tableaux, le
compilateur ne sera pas capable de détecter l'erreur, et nous
obtiendrions une erreur à l'execution bien après la compilation ce qui
est bien pire !</p>
<h3 id="Commentutiliserunfoncteur">Comment utiliser un foncteur ?</h3>

<p>La librairie standard définit le module <code>Set</code>, qui fournit un
foncteur <code>Make</code>. Ce foncteur requiert un argument, qui est un
module contenant (au moins) deux choses: le type des éléments donné par
<code>t</code> et la fonction de comparaison donnée par <code>compare</code> .
L'important est de s'assurer que la même fonction de comparaison sera
toujours utilisée, même si le programmeur commet une erreur.</p>
<p>Par exemple, si nous voulons un ensemble d'entiers, il faut utiliser
ceci:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Int_set</span> <span class="ocaml-variable"></span>= <span class="ocaml-module">Set</span>.Make (<span class="governing">struct</span>
                             <span class="governing">type</span> <span class="type">t</span> = int
                             <span class="governing">let </span><span class="ocaml-variable">compare</span> = compare
                           <span class="governing">end</span>) </code></pre>

<p>Pour les ensembles de chaînes, cela est même plus simple car la
librairie standard fournit un module <code>String</code> avec un type
<code>t</code> et une fonction <code>compare</code>. On peut donc créer, à peu de
frais, un module pour la manipulation des ensembles de chaînes de
caractères:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">String_set</span> <span class="ocaml-variable"></span>= <span class="ocaml-module">Set</span>.Make (String)</code></pre>

<p>(les parenthèses sont obligatoires !)</p>
<h3 id="Commentdfinirunfoncteur">Comment définir un foncteur ?</h3>

<p>Un foncteur avec un argument peut être définit comme ceci:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>=
<span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p>où <code>X</code> est le module passé en argument, et <code>X\_type</code> est sa
signature, qui est obligatoire.</p>
<p>La signature du module obtenu peut elle même être restreinte à l'aide la
syntaxe habituelle:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>: <span class="ocaml-module">Y_type</span> =
<span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p>ou bien en le spécifiant dans le fichier <code>.mli</code>:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>: Y_type</code></pre>

<p>La syntaxe des foncteurs reste cependant difficile à assimiler. Il est
donc préférable de jeter un coup d'oeil aux fichier sources
<code>set.ml</code> ou <code>map.ml</code> dans la librairie standard. Une
dernière remarque: les foncteurs ont été conçus pour aider les
programmeurs et non pas pour améliorer les performances. L'execution est
même plus lente, à moins d'utiliser un défoncteur comme
<code>ocamldefun</code>, qui requiert un accès au code source du foncteur.</p>
<h2 id="Manipulationpratiquedesmodules">Manipulation pratique des modules</h2>

<h3 id="Afficherl39interfaced39unmodule">Afficher l'interface d'un module</h3>

<p>En <code>toplevel</code>, il est possible de visualiser le contenu d'un
module en tapant:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">M</span> = <span class="ocaml-module">List</span></code></pre>

<p>On obtient alors:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">M</span> = <span class="ocaml-module">List</span></span><span class="ocaml-prompt">;;</span><br><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module M = List
</span></code></pre>

<p>De toute façon, il existe une documentation pour la plupart des modules
(on peut aussi utiliser <code>ocamlbrowser</code>, fourni avec <code>labltk</code>).</p>
<h3 id="Insertiondansunmodule">Insertion dans un module</h3>

<p>Supposons que nous sentions qu'une fonction manque au module standard
<code>List</code> et que nous désirions qu'elle en fasse partie intégrante.
Il est possible d'utiliser l'instruction <code>include</code> au sein d'un
fichier <code>extensions.ml</code> afin d'insérer notre fonction:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">List</span> <span class="ocaml-variable"></span>=
<span class="governing">struct</span>
  <span class="governing">include</span> List
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">optmap</span> <span class="ocaml-variable">f </span>= <span class="keyword">function</span>
    | [] -&gt; []
    | hd :: tl -&gt;
       <span class="keyword">match</span> f hd <span class="keyword">with</span>
       | None -&gt; optmap f tl
       | Some x -&gt; x :: optmap f tl
<span class="governing">end</span></code></pre>

<p>Nous avons créé un nouveau module <code>Extensions.List</code> contenant , en
plus des fonctions habituelles du module <code>List</code>, une nouvelle
fonction <code>optmap</code>.  Depuis un autre fichier, il nous suffit
d'ouvrir notre module <code>Extensions</code> pour que celui-ci «&nbsp;écrase&nbsp;» le
module <code>List</code> standard&nbsp;:</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Extensions</span>
...
<span class="ocaml-module">List</span>.optmap ...</code></pre>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	<!-- footer							-*-html-*- -->
<div class="column">
  <div class="entry">
    <h1><a href="https://ocaml.org/learn/index.fr.html">Apprendre</a></h1>
    <ul>
      <li><a href="https://ocaml.org/learn/taste.fr.html">Exemples de code</a></li>
      <li><a href="https://ocaml.org/learn/tutorials/index.fr.html">Tutoriels</a></li>
      <li><a href="https://ocaml.org/learn/books.html">Livres</a></li>
      <li><a href="https://ocaml.org/learn/success.fr.html">Cas d'usage</a></li>
      <li><a href="https://ocaml.org/learn/tutorials/"></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="https://ocaml.org/docs/index.fr.html">Documentation</a></h1>
    <ul>
      <li><a href="https://ocaml.org/docs/install.fr.html">Installer OCaml</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manuel</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Contributions</a></li>
      <li><a href="https://ocaml.org/releases/index.fr.html">Compiler Releases</a></li>
      <li><a href="https://ocaml.org/docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="https://ocaml.org/community/index.fr.html">Communauté</a></h1>
    <ul>
      <li><a href="https://ocaml.org/community/mailing_lists.fr.html">Lieux de discussion</a></li>
      <li><a href="https://ocaml.org/meetings/index.fr.html">Rencontres</a></li>
      <li><a href="https://ocaml.org/community/planet/">Nouvelles</a></li>
      <li><a href="https://ocaml.org/community/support.fr.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Signaler un bug d'OCaml</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Contact</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="https://ocaml.org/about.html">À propos de ce site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Dépôt GitHub</a></li>
      <li><a href="https://ocaml.org/contributors.fr.html">Crédits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    <!-- Load javascript from CDN -->
    <script type="text/javascript" src="Modules%20%E2%80%93%20OCaml_fichiers/bootstrap.js"></script>

    
    <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37808023-1']);
    _gaq.push(['_setDomainName', 'ocaml.org']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

    </script>
    <!-- Piwik -->
    <script type="text/javascript">
      var _paq = _paq || [];
      _paq.push(['setCookieDomain', '*.ocaml.org']);
      _paq.push(['setDocumentTitle', 'Modules']);
      _paq.push(['setDoNotTrack', true]);
      _paq.push(['setCustomVariable', 1, 'Page language',
         'French',
         'page']);
      _paq.push(['trackPageView']);
      _paq.push(['enableLinkTracking']);

      (function() {
        var u=(('https:' == document.location.protocol) ? 'https' : 'http') + '://ocaml.org/piwik/';
        _paq.push(['setTrackerUrl', u+'piwik.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0]; g.type='text/javascript';
        g.defer=true; g.async=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
      })();
    </script>
    <noscript><p><img src="//ocaml.org/piwik/piwik.php?idsite=1"
		      style="border:0;" alt="" /></p></noscript>
    <!-- End Piwik Code --> <!-- ifndef staging -->

  

</body></html>